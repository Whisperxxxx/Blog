<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>排序算法</title>
    <link rel="stylesheet" href="c.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="index.html">首页</a></li>
                <li><a href="algorithms.html">返回</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <h1>排序算法</h1>
        <div>
            <h2>1.冒泡排序（Bubble Sort）</h2>
            <p>
                最简单的排序算法，通过重复的相邻元素比较，将较大的元素冒泡到列表的末端。
                <br><bold>步骤：</bold>
                <ul>
                    <li>遍历数组，每次比较相邻的两个元素。</li>
                    <li>如果前面的元素大于后面的元素，交换它们的位置。</li>
                    <li>经过一轮遍历后，最大的元素将会出现在数组的末尾。</li>
                    <li>重复上述过程，直到整个数组有序。</li>
                </ul>
                <bold>C#实现：</bold>
                <pre><code>
public void BubbleSort(int[] arr)
{
    int n = arr.Length;
    for (int i = 0; i < n-1; i++)
    {
        for (int j = 0; j < n-1-i; j++)
        {
            if(arr[j] > arr[j+1])
            {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
                </code></pre>
                <bold>复杂度分析：</bold>
                <ul>
                    <li><bold>稳定排序</bold></li>
                    <li><bold>时间复杂度：</bold>O(n²)</li>
                    <li><bold>空间复杂度：</bold>O(1)</li>
                </ul>
            </p>
        </div>

        <div>
            <h2>2.选择排序（Selection Sort）</h2>
            <p>
                每次从未排序的部分中选择最小（或最大）的元素，将其放到已排序部分的末尾。
                <br><bold>步骤：</bold>
                <ul>
                    <li>从数组中选择最小或最大的元素，放到序列的起始。</li>
                    <li>再次从未排序的部分中找到最小或最大元素，放到已排序部分的起始。</li>
                    <li>重复上述过程，直到整个数组有序。</li>
                </ul>
                <bold>C#实现：</bold>
                <pre><code>
public void SelectionSort(int[] arr)
{
    int n = arr.Length;
    for (int i = 0; i < n-1; i++)
    {
        int minIndex = i;
        for (int j = i+1; j < n; j++)
        {
            if (arr[j] < arr[minIndex])
            {
                minIndex = j;
            }
        }
        int temp = arr[minIndex];
        arr[minIndex] = arr [i];
        arr [i] = temp;
    }
}
                </code></pre>
                <bold>复杂度分析：</bold>
                <ul>
                    <li><bold>不稳定排序</bold></li>
                    <li><bold>时间复杂度：</bold>O(n²)</li>
                    <li><bold>空间复杂度：</bold>O(1)</li>
                </ul>
            </p>
        </div>

        <div>
            <h2>3.插入排序（Insertion Sort）</h2>
            <p>
                将数组分为已排序和未排序部分，每次从未排序部分中拿一个元素，将其插入到已排序部分的正确位置。
                <br><bold>步骤：</bold>
                <ul>
                    <li>从数组的第二个元素开始，将其插入到前面的有序部分中。</li>
                    <li>逐步将未排序的元素插入到已排序部分，直到整个数组有序。</li>
                </ul>
                <bold>C#实现：</bold>
                <pre><code>
public void InsertionSort(int[] arr)
{
    for (int i = 1; i < arr.Length; i++)
    {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
                </code></pre>
                <bold>复杂度分析：</bold>
                <ul>
                    <li><bold>稳定排序</li>
                    <li><bold>时间复杂度：</bold>O(n²)</li>
                    <li><bold>空间复杂度：</bold>O(1)</li>
                </ul>
            </p>
        </div>

        <div>
            <h2>4.希尔排序（Shell Sort）</h2>
            <p>
                希尔排序是插入排序的优化版。通过将数组按一定的步长（gap）分组，每组进行插入排序。
                <br><bold>步骤：</bold>
                <ul>
                    <li>选择步长序列,初始的步长通常取数组长度的一半，然后逐渐减半，直到步长为1。</li>
                    <li>按步长分组，然后对每个组进行插入排序。</li>
                    <li>重复上述步骤直到步长为1，然后对数组进行一次插入排序。</li>
                </ul>
                <bold>C#实现：</bold>
                <pre><code>
public void ShellSort(int[] arr)
{
    int n = arr.Length;
    
    for (int gap = n/2; gap > 0; gap /= 2)
    {
        for (int i = gap; i < n; i++)
        {
            int key = arr[i];
            j = i;
            
            while (j >= gap && key < arr[j-gap])
            {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = key;
        }
    }
}
                </code></pre>
                <bold>复杂度分析：</bold>
                <ul>
                    <li><bold>最坏时间复杂度：</bold>O(n²)</li>
                    <li><bold>平均时间复杂度：</bold>O(nlog²n)</li>
                    <li><bold>最好时间复杂度：</bold>O(n)</li>
                    <li><bold>空间复杂度：</bold>O(1)</li>
                </ul>
            </p>
        </div>
        <div>
            <h2>5.归并排序（Merge Sort）</h2>
            <p>
                基于分治思想，通过不断将数组分割成两部分，再合并排序后的子数组，最终完成排序。
                <br><bold>步骤：</bold>
                <ul>
                    <li>递归地将数组分成两半，直到每部分只有一个元素。</li>
                    <li>合并两部分，使之有序。</li>
                </ul>
                <bold>C#实现：</bold>
                <pre><code>
public class Solution
{
    public void MergeSort(int[] arr)
    {
        if (arr == null || arr.Length <= 1) return;
        int[] temp = new int[arr.Length];
        MergeSort(arr, 0, arr.Length - 1, temp);
    }

    private void MergeSort(int[] arr, int left, int right, int[] temp)
    {
        if (left < right)
        {
            int mid = left + (right - left) / 2;
            MergeSort(arr, left, mid, temp);
            MergeSort(arr, mid + 1, right, temp);
            Merge(arr, left, mid, right, temp);
        }
    }

    private void Merge(int[] arr, int left, int mid , int right, int[] temp)
    {
        int i = left;
        int j = mid + 1;
        int k = left;

        while (i <= mid && j <= right)
        {
            if (arr[i] <= arr[j])
            {
                temp[k++] = arr[i++];
            }
            else
            {
                temp[k++] = arr[j++];
            }
        }

        while (i <= mid)
        {
            temp[k++] = arr[i++];
        }

        while (j <= right)
        {
            temp[k++] = arr[j++];
        }
        for (k = left, k <= right; k++)
        {
            arr[k] =  temp[k];
        }
    }
}


                </code></pre>
                <bold>复杂度分析：</bold>
                <ul>
                    <li><bold>最坏时间复杂度：</bold>O(nlogn)</li>
                    <li><bold>平均时间复杂度：</bold>O(nlogn)</li>
                    <li><bold>最好时间复杂度：</bold>O(nlogn)</li>
                    <li><bold>空间复杂度：</bold>O(n)</li>
                </ul>
            </p>
            </div>

            <h2>6.快速排序（Quick Sort）</h2>
            <p>
                快速排序使用分治法，通过选择一个基准元素，将数组划分为小于基准和大于基准的两部分，递归地对两部分进行排序，最终完成排序。
                <br><bold>步骤：</bold>
                <ul>
                    <li>从数组中选择一个基准元素。</li>
                    <li>使所有小于基准的元素位于基准的左侧，所有大于基准的元素位于基准的右侧。此过程称为“分区”。</li>
                    <li>对基准左侧和右侧的子数组分别递归地进行快速排序，直到每个子数组只包含一个元素或为空。</li>
                </ul>
                <bold>C#实现：</bold>
                <pre><code>
#递归法
public void QuickSort(int[] arr)
{
    if (arr == null || arr.Length <= 1) return; 

    RecursiveQuickSort(arr, 0, arr.Length - 1);
}

public void RecursiveQuickSort(int[] arr, int left, int right)
{
    if (left < right)
    {
        int pivotIndex = Partition(arr, left, right);
        RecursiveQuickSort(arr, left, pivotIndex - 1);
        RecursiveQuickSort(arr, pivotIndex + 1, right);
    }
}

private int Partition(int[] nums, int start, int end)
{
    Random rand = new Random();
    int randIndex = rand.Next(start, end + 1);
    Swap(nums, randIndex, end);
    int left = start;
    int right = end -1;
    int pivot = nums[end];

    while (left <= right)
    {
        while (left <= right && nums[left] < pivot)
        {
            left++;
        }

        while (left <= right && nums[right] > pivot)
        {
            right--;
        }
        if (left <= right)
        {
            Swap(nums, left, right);
            left++;
            right--;

        }
    }
    Swap(nums, left, end);
    return left;
}

private void Swap(int[] nums, int left, int right)
{
    int temp = nums[left];
    nums[left] = nums[right];
    nums[right] = temp;
}
                </code></pre>
                <bold>区别：</bold>
                <p>
                    <bold>递归版：</bold>
                    <br>递归版中再次调用QuickSort方法时，系统会自动在调用栈（call stack）中为该函数调用<bold>创建一个新的栈帧。</bold>每个栈帧保存该函数调用的状态信息，包括局部变量、参数等。当递归调用深度增加时，每次递归调用都会在调用栈上增加一个新的栈帧，这就是为什么递归调用可能导致<bold>栈溢出（stack overflow）</bold>，如果递归深度过大，调用栈可能耗尽。
                    <br><bold>迭代版：</bold>
                    <br>stack.Push 是程序员显式使用的一个数据结构操作，它不是函数调用，因此它<bold>不会创建新的系统栈帧。</bold>stack.Push 只是把某些数据（比如数组的左右区间边界）压入栈，并不会产生新的系统调用栈，也不会保存函数调用状态。
                    stack.Pop 只是从栈中取出数据，并继续处理这些数据。所以在迭代版中，系统的调用栈保持不变，所有的状态管理都通过你显式操作的栈来完成。
                </p>
                <bold>复杂度分析：</bold>
                <ul>
                    <li><bold>最坏时间复杂度：</bold>O(n²)</li>
                    <li><bold>平均时间复杂度：</bold>O(nlogn)</li>
                    <li><bold>最好时间复杂度：</bold>O(nlogn)</li>
                    <li><bold>最坏空间复杂度：</bold>O(n)</li>
                    <li><bold>最好空间复杂度：</bold>O(logn)</li>
                </ul>
            </p>
        </div>
        <div>

            <div>
                <h2>7.堆排序（Heap Sort）</h2>
                <p>
                    堆排序是一种基于二叉堆数据结构的选择排序，主要通过将数组构造成一个最大堆或最小堆，然后逐一提取堆顶元素，完成排序。
                    <br><bold>步骤：</bold>
                    <ul>
                        <li>将数组构造成一个最大堆。</li>
                        <li>将堆顶元素（最大值）与堆末元素交换，减少堆的大小。</li>
                        <li>重新调整剩余元素为最大堆，重复以上过程直到排序完成。</li>
                    </ul>
                    <bold>C#实现：</bold>
                    <pre><code>

                    </code></pre>
                    <bold>复杂度分析：</bold>
                    <ul>
                        <li><bold>最坏时间复杂度：</bold>O(n²)</li>
                        <li><bold>平均时间复杂度：</bold>O(nlog²n)</li>
                        <li><bold>最好时间复杂度：</bold>O(n)</li>
                        <li><bold>空间复杂度：</bold>O(1)</li>
                    </ul>
                </p>
            </div>
    </main>
    <footer>
    </footer>
</body>
</html>
