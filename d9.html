<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二叉搜索树</title>
    <link rel="stylesheet" href="c.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="index.html">首页</a></li>
                <li><a href="datastruct.html">返回</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <h1>二叉搜索树</h1>
        <h2>定义</h2>
        <p>二叉搜索树是一种特殊的二叉树，它满足以下两个条件：
            <br>&nbsp;&nbsp;&nbsp;&nbsp;1. 左子树的所有节点值均小于根节点值。
            <br>&nbsp;&nbsp;&nbsp;&nbsp;2. 右子树的所有节点值均大于根节点值。
        <br>在二叉搜索树中，任意节点的左子树和右子树也是二叉搜索树。
        <h2>二叉搜索树的基本特性</h2>
        <p>
            <ul>
                <li>
                    <bold>1.中序遍历的顺序是递增的</bold>
                    <br>对于二叉搜索树，中序遍历(左 - 根 - 右), 那么得到的节点值是递增的
                </li>
                <li>
                    <bold>2.时间复杂度</bold>
                    <br>对于一棵<bold>平衡</bold>的二叉搜索树，查找，插入和删除的操作复杂度都是O(log n),但是如果树退化为链表（即每个节点只有一个子节点），查找的时间复杂度变为O(n).
                </li>
            </ul>
        </p>
        <h2>二叉搜索树的操作</h2>
        <p>
            <pre><code>
public class TreeNode
{
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)
    {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class BinarySearchTree
{
    // 递归查找
    public TreeNode RecSearch(TreeNode root, int target)
    {
        if (root == null || root.val == target)
        {
            return root;
        }

        if (target < root.val)
        {
            return RecSearch(root.left, target);
        }
        return RecSearch(root.right, target);
    }
    // 迭代查找
    public TreeNode ItrSearch(TreeNode root, int target)
    {
        while (root != null)
        {
            if (root.val == target)
            {
                return root;
            }

            root = target < root.val ? root.left :root.right;
        }

        return null;
    }

    // 查找最小 时间复杂度O(h) 
    public TreeNode FindMin(TreeNode root)
    {
        if (root == null) return null;
        while (root.left != null)
        {
            root = root.left;
        }
        return root;
    }

    // 查找最大
    public TreeNode FindMax(TreeNode root)
    {
        if (root == null) return null;
        while (root.right != null)
        {
            root = root.right;
        }
        return root;
    }

    // 插入
    public TreeNode Insert(TreeNode root, int val)
    {
        TreeNode newNode = new TreeNode(val);
        if (root == null) return newNode;

        if (val < root.val)
        {
            root.left = Insert(root.left, val);
        }
        else
        {
            root.right = Insert(root.right, val);
        }
        return root;
    }

    // 删除
    public TreeNode Delete(TreeNode root, int val)
    {
        if (root == null) return null;

        if (val < root.val)
        {
            root.left = Delete(root.left, val);
        }
        else if (val > root.val)
        {
            root.right = Delete(root.right, val);
        }
        else
        {
            // 叶节点, 即无子节点
            if (root.left == null && root.right == null)
            {
                return null;
            }
            // 只有一个子节点
            else if (root.left == null)
            {
                return root.right;
            }
            else if (root.right == null)
            {
                return root.left;
            }
            // 有两个子节点
            // 找到中序后继 (中序前继就是换成FindMax(left))
            TreeNode temp = FindMin(root.right);
            root.val = temp.val;
            root.right = Delete(root.right, temp.val);          
        }
        return root;
    }
}
            </code></pre>
        </p>
    </main>
    <footer>
    </footer>
</body>
</html>
